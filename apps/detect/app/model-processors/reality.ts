import { MediaType } from "../data/media"
import { ManipulationModelInfo, Processor, mkResult } from "../data/model"

export type RDModelName = keyof typeof models

export type RDModel = {
  name: RDModelName
  data: {
    decision: string
    score?: number
    reason?: string
  }
  status: string
  normalizedPredictionNumber: number
  rollingAvgNumber?: number
  finalScore: number
}

type UserInfo = any
type WebhookUrl = any
type MediaMetadataInfo = any

export type RDMediaInfo = {
  name: string
  filename: string
  originalFileName: string
  storageLocation: string
  convertedFileLocation: string
  requestId: string
  uploadedDate: string
  mediaType: string
  userInfo: UserInfo
  thumbnail: string
  contentPreview: string | null
  userId: string
  institutionId: string
  releaseVersion: string
  webhookUrls: WebhookUrl[]
  createdAt: string
  updatedAt: string
  overallStatus: string
  models: RDModel[]
  rdModels: string[]
  youtubeLink: string
  media_metadata_info: MediaMetadataInfo
  aggregationResultUrl: string
  modelMetadataUrl: string
  // if we analyzed the audio along with a video, these will be set
  showAudioResult: boolean
  audioExtractionFileName: string
  audioRequestId: string
  audioExtractionProcessed: boolean
  // if we fail to submit media to RD, we'll create an { error: ... } record
  error?: string
}

function modelResult(rm: RDModel) {
  const res = mkResult(rm.name, "unknown", 0)
  const score = rm.data?.score || 0
  switch (rm.status) {
    default:
      console.warn(`Unexpected model status: ${rm.status}`)
      console.log(rm)
      break
    case "ANALYZING":
      break
    case "NOT_EVALUATED":
    case "NOT_APPLICABLE":
    case "UNABLE_TO_EVALUATE":
      res.rank = "n/a"
      break
    case "AUTHENTIC":
      res.rank = "low"
      res.score = score
      break
    case "SUSPICIOUS":
      res.rank = "uncertain"
      res.score = score
      break
    case "FAKE":
      res.rank = "high"
      res.score = score
      break
  }
  return res
}

const typeMatches = (rm: RDModel, type: MediaType) => models[rm.name] && models[rm.name].mediaType == type

const videoProcessor: Processor<RDMediaInfo> = {
  id: "rd-video",
  name: "Reality Defender",
  mediaType: "video",
  maxPending: 3,
  maxSize: 100 * 1024 * 1024,
  timeoutMs: 30 * 60 * 1000, // 30 minutes
  adapt: (res) => res.models.filter((rm) => typeMatches(rm, "video")).map((rm) => modelResult(rm)),
  check: (res) => res.error,
  availability: "archived",
}

const videoModels = {
  "rd-vid-ensemble": {
    type: "manipulation",
    mediaType: "video",
    manipulationCategory: "other",
    processor: videoProcessor,
    name: "Ensemble Score",
    descrip:
      "Combines the outputs (score) of multiple models to see if an image or video is AI-generated or manipulated.",
    policy: "ignore",
    hideCard: true,
  } as ManipulationModelInfo,
  "rd-huron-vid": {
    type: "manipulation",
    mediaType: "video",
    manipulationCategory: "face",
    processor: videoProcessor,
    name: "Face Blending Detector",
    descrip:
      "Detects face blending, a process in which AI takes two or more images to create a new composite facial image.",
    policy: "ignore",
  } as ManipulationModelInfo,
  "rd-erie-vid": {
    type: "manipulation",
    mediaType: "video",
    manipulationCategory: "face",
    processor: videoProcessor,
    name: "Universal",
    descrip: "Distinguishes real faces from deepfake faces.",
    policy: "ignore",
  } as ManipulationModelInfo,
  "rd-tahoe-vid": {
    type: "manipulation",
    mediaType: "video",
    manipulationCategory: "imagen",
    processor: videoProcessor,
    name: "AI-Generated Video Detector",
    descrip: "Detects video generated by generative AI models.",
    policy: "ignore",
  } as ManipulationModelInfo,
}

const imageProcessor: Processor<RDMediaInfo> = {
  id: "rd-image",
  name: "Reality Defender",
  mediaType: "image",
  maxPending: 3,
  maxSize: 10 * 1024 * 1024,
  adapt: (res) => res.models.filter((rm) => typeMatches(rm, "image")).map((rm) => modelResult(rm)),
  check: (res) => res.error,
  availability: "archived",
}

const imageModels = {
  "rd-img-ensemble": {
    type: "manipulation",
    mediaType: "image",
    manipulationCategory: "other",
    processor: imageProcessor,
    name: "Ensemble Score",
    descrip:
      "Combines the outputs (score) of multiple models to see if an image or video is AI-generated or manipulated.",
    policy: "ignore",
    hideCard: true,
  } as ManipulationModelInfo,
  "rd-pine-img": {
    type: "manipulation",
    mediaType: "image",
    manipulationCategory: "noise",
    processor: imageProcessor,
    name: "Visual Noise Analysis",
    descrip: "Tests for random variation of brightness or color information in pixel values of images.",
    policy: "ignore",
  } as ManipulationModelInfo,
  "rd-oak-img": {
    type: "manipulation",
    mediaType: "image",
    manipulationCategory: "face",
    processor: imageProcessor,
    name: "Faceswap Detector",
    descrip:
      "Detects face swapping, a process in which AI transfers the identity of one face " +
      " to another while keeping all other details, such as facial expression.",
    policy: "ignore",
  } as ManipulationModelInfo,
  "rd-elm-img": {
    type: "manipulation",
    mediaType: "image",
    manipulationCategory: "imagen",
    processor: imageProcessor,
    name: "Stable Diffusion Detector",
    descrip: "Detects the signature of images created by Stable Diffusion.",
    policy: "ignore",
  } as ManipulationModelInfo,
  "rd-cedar-img": {
    type: "manipulation",
    mediaType: "image",
    manipulationCategory: "imagen",
    processor: imageProcessor,
    name: "GANs Detector",
    descrip: "Detects the signature of images created by Generative Adversarial Networks (GANs).",
    policy: "ignore",
  } as ManipulationModelInfo,
}

const audioProcessor: Processor<RDMediaInfo> = {
  id: "rd-audio",
  name: "Reality Defender",
  mediaType: "audio",
  maxPending: 3,
  maxSize: 20 * 1024 * 1024,
  adapt: (res) => res.models.filter((rm) => typeMatches(rm, "audio")).map((rm) => modelResult(rm)),
  check: (res) => res.error,
  availability: "archived",
}

const audioModels = {
  "rd-aud-ensemble": {
    type: "manipulation",
    mediaType: "audio",
    manipulationCategory: "audio",
    processor: audioProcessor,
    name: "Ensemble",
    descrip: "Computes ensemble score over multiple models.",
    policy: "ignore",
    hideCard: true,
  } as ManipulationModelInfo,
  "rd-everest-aud": {
    type: "manipulation",
    mediaType: "audio",
    manipulationCategory: "audio",
    processor: audioProcessor,
    name: "Advanced Foundation Model Detector",
    descrip: "Detects AI-synthesized audio using a larger foundation model trained over a larger, diverse data set.",
    policy: "ignore",
    trackPolicy: "ignore",
  } as ManipulationModelInfo,
  "rd-tak22-aud": {
    type: "manipulation",
    mediaType: "audio",
    manipulationCategory: "audio",
    processor: audioProcessor,
    name: "Audio Foundation Model Detector",
    descrip:
      "Detects AI-generated audio using a foundation audio model that has been trained on a vast amount of data such as speech, music, and environmental sounds.",
    policy: "ignore",
    trackPolicy: "ignore",
  } as ManipulationModelInfo,
}

export const models = {
  ...videoModels,
  ...imageModels,
  ...audioModels,
}

export const processors = {
  "rd-video": videoProcessor,
  "rd-image": imageProcessor,
  "rd-audio": audioProcessor,
}
