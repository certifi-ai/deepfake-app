import { ManipulationModelInfo, Processor, mkModelResult } from "../data/model"
import { Generator, GeneratorPrediction, MIN_SCORE } from "../generators"

export type ApiResponse = {
  id: string
  created_at: string
  report: Record<string, any>
  error?: string
}

type Judgement = {
  confidence: number
  is_detected: boolean
}

export type ImageGenerators = {
  midjourney: Judgement
  dall_e: Judgement
  stable_diffusion: Judgement
  this_person_does_not_exist: Judgement
  adobe_firefly: Judgement
}

export type ImageApiResponse = ApiResponse & {
  report: {
    verdict: "ai" | "human"
    ai: Judgement
    human: Judgement
    generator: ImageGenerators
  }
  facets: {
    quality: {
      version: string
      is_detected: boolean
    }
    nsfw: {
      version: string
      is_detected: boolean
    }
  }
}

export type AudioApiResponse = ApiResponse & {
  report: {
    verdict: "ai" | "human"
    confidence: number
  }
}

const imageId = "aion-image"
const imageProcessor: Processor<ImageApiResponse> = {
  id: imageId,
  name: "AI or Not",
  mediaType: "image",
  maxPending: 0,
  check: (res) => res.error,
  adapt: (api) => {
    const report = api.report
    const generatorPrediction = getGeneratorPrediction(report.generator)
    return report.verdict == "ai"
      ? [mkModelResult(imageId, imageModel, report.ai.confidence, { generator: generatorPrediction })]
      : [mkModelResult(imageId, imageModel, 1 - report.human.confidence, { generator: generatorPrediction })]
  },
  availability: "disabled",
}

const imageModel: ManipulationModelInfo = {
  type: "manipulation",
  mediaType: "image",
  manipulationCategory: "imagen",
  processor: imageProcessor,
  name: "AI Image Generator Analysis",
  descrip:
    "Analyzes image for indications that it was generated by popular AI " +
    "image generators, like MidJourney, Dall-E, Stable Diffusion and thispersondoesnotexist.com.",
  policy: "ignore",
}

const audioId = "aion-audio"
const audioProcessor: Processor<AudioApiResponse> = {
  id: audioId,
  name: "AI or Not",
  mediaType: "audio",
  maxPending: 0,
  check: (res) => res.error,
  adapt: (api) => {
    const score = api.report.confidence
    return [mkModelResult(audioId, audioModel, score)]
  },
  availability: "archived",
}
const audioModel: ManipulationModelInfo = {
  type: "manipulation",
  mediaType: "audio",
  manipulationCategory: "audio",
  processor: audioProcessor,
  name: "Audio Analysis",
  descrip: "Analyzes audio for indications that it was generated by an AI audio generator.",
  policy: "ignore",
  trackPolicy: "ignore",
}

export function getGeneratorPrediction(generators: ImageGenerators): GeneratorPrediction | undefined {
  try {
    const candidates = Object.entries(generators)
      .filter(([, judgement]) => judgement.is_detected)
      .flatMap(([candidate, judgement]) => {
        const maybeGenerator = mapGenerator(candidate)
        return maybeGenerator ? [{ generator: maybeGenerator, score: judgement.confidence }] : []
      })
      // sort by score so we only take the highest scoring generator
      .sort((a, b) => b.score - a.score)

    // only report a generator if the confidence is 0.5 or above
    if (candidates.length > 0 && candidates[0].score >= MIN_SCORE) {
      return candidates[0]
    }
  } catch (error) {
    console.log(`Failed to parse generator prediction from aion response:\n${generators}`, error)
  }

  return undefined
}

function mapGenerator(candidate: string): Generator | undefined {
  switch (candidate) {
    case "dall_e":
      return "dalle"
    case "midjourney":
      return "midjourney"
    case "stable_diffusion":
      return "stablediffusion"
    case "this_person_does_not_exist":
      return "gan"
    case "adobe_firefly":
      return "adobefirefly"
    default:
      return undefined
  }
}

export const models = {
  [imageId]: imageModel,
  [audioId]: audioModel,
}

export const processors = {
  [imageId]: imageProcessor,
  [audioId]: audioProcessor,
}
